#pragma config(Sensor, S1,     touchA,         sensorEV3_Touch)
#pragma config(Sensor, S3,     us_sensor,      sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     touchB,         sensorEV3_Touch)
#pragma config(Motor,  motorB,          left_motor,    tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          right_motor,   tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int ScreenHeight =127;
const int ScreenWidth  =177;

typedef struct{
	int NorthWall;
	int EastWall;
	int SouthWall;
	int WestWall;
	int Visited;
	int VisitCount;
}Cell;

Cell Grid[4][6];

// Start Facing North
int RobotDirection=0; // 0=North, 1=East, 2=South, 3=West

// Start in the 0,0 Cell
int StartPosRow=0; // Starting position
int StartPosCol=0;

int CurrentPosRow=StartPosRow; // Starting position
int CurrentPosCol=StartPosCol;

int TargetPosRow=3;
int TargetPosCol=0;
int previousTile[] = {0, 0};
int path[100];
int moves = 0;

int Solver();
void GridInit();
void WallGen();
void GridDraw();
void orient(int target);
void fwd();
void DrawBot();
void DisplayStartandEnd();
void moveRobot(int leftMotorPosition, int rightMotorPosition, int speed);
void turnRight();
void turnLeft();
void turnRobot(int left, int right);

int speed = 25;
int turnSpeed = 20;
int turn = 124;
int tileDegrees = 480;
int tileSize = 22.5;
int wallDistance = 5.8;

// 128.4, 129.2 @ 20
// Not goot 133.2, 129,2 @ 25
int leftTurn = 130.2;;
int rightTurn = 129.2;

task main()
{
	GridInit();
	WallGen();
	// Sound start signal 300hz for 2s
	//playTone(300, 200);

	while( (CurrentPosRow!=TargetPosRow) || (CurrentPosCol!=TargetPosCol)){
		Solver();
	}
	while(true){
		DisplayCenteredBigText('5', "Maze Solved!");
		sleep(500);
		eraseDisplay();
		sleep(500);
	}
}

int nextRightPrevious() {
	if (RobotDirection == 0) {
		if (CurrentPosCol + 1  > 5) {
			return 0;
		}
		if (CurrentPosCol + 1 == previousTile[1]) {
			return 1;
		}
	}
	else if (RobotDirection == 1) {
		if (CurrentPosRow - 1  < 0) {
			return 0;
		}
		if (CurrentPosRow - 1 == previousTile[0]) {
			return 1;
		}
	}
	else if (RobotDirection == 2) {
		if (CurrentPosCol - 1  < 0) {
			return 0;
		}
		if (CurrentPosCol -  1 == previousTile[0]) {
			return 1;
		}
	}
	else if (RobotDirection == 3) {
		if (CurrentPosRow + 1  > 3) {
			return 0;
		}
		if (CurrentPosRow + 1 == previousTile[1]) {
			return 1;
		}
	}
	return 0;
}

void turnLeft() {
	turnRobot(-leftTurn, rightTurn);
    RobotDirection = RobotDirection - 1;
    if (RobotDirection < 0) {
        RobotDirection = 3;
   }
}

void turnRight() {
    turnRobot(leftTurn, -rightTurn);
    RobotDirection = (RobotDirection + 1) % 4;
}

void turn180() {
		turnRobot(leftTurn * 2, -rightTurn * 2);
  	RobotDirection = (RobotDirection + 2) % 4;
}

void turnRobot(int left, int right) {
  resetMotorEncoder(left_motor);
	resetMotorEncoder(right_motor);
	setMotorTarget(left_motor, left, turnSpeed);
	setMotorTarget(right_motor, right, turnSpeed);
	waitUntilMotorStop(left_motor);
	waitUntilMotorStop(right_motor);
	sleep(100);
}

void moveRobot(int leftMotorPosition, int rightMotorPosition, int speed) {
	resetMotorEncoder(left_motor);
	resetMotorEncoder(right_motor);
	setMotorSyncEncoder(left_motor, right_motor, 0, leftMotorPosition, speed);
	//setMotorTarget(left_motor, leftMotorPosition - 2, speed);
	//setMotorTarget(right_motor, rightMotorPosition - 2, speed);
	waitUntilMotorStop(left_motor);
	waitUntilMotorStop(right_motor);
	sleep(100);
}

//=====================================================================
void GridInit(){
	for(int i=0;i<4;i++){
		for(int j=0;j<6;j++){
			Grid[i][j].NorthWall=-1;
			Grid[i][j].EastWall=-1;
			Grid[i][j].WestWall=-1;
			Grid[i][j].SouthWall=-1;
			Grid[i][j].Visited=0;
			Grid[i][j].VisitCount=0;
		}
	}
	Grid[StartPosRow][StartPosCol].Visited=1;
	/* Initialize pathset */
	for (int i = 0; i < 100; i++) {
		path[i] = -1;
	}
}
//=====================================================================
void WallGen(){
	int i=0;
	int j=0;
	// Build a 'wall' around the grid
	for(i=0;i<4;i++){
		Grid[i][0].WestWall=1;
		Grid[i][5].EastWall=1;
		Grid[i][0].VisitCount += 1;
		Grid[i][5].VisitCount += 1;
	}

	for(j=0;j<6;j++){
		Grid[0][j].SouthWall=1;
		Grid[3][j].NorthWall=1;
		Grid[0][j].VisitCount+=1;
		Grid[3][j].VisitCount+=1;
	}
}

//=====================================================================
void GridDraw(){
	int XStart=0;
	int YStart=0;
	int XEnd  =0;
	int YEnd  =0;
	for(int i=0;i<4;i++){
		for(int j=0;j<6;j++){
			if(Grid[i][j].NorthWall==1){
					XStart= j   *ScreenWidth/6;
					YStart=(i+1)*ScreenHeight/4;
					XEnd  =(j+1)*ScreenWidth/6;
					YEnd  =(i+1)*ScreenHeight/4;
					drawLine(XStart,YStart,XEnd,YEnd);
			}
			if (Grid[i][j].EastWall==1){
					XStart=(j+1)*ScreenWidth/6;
					YStart=(i)*ScreenHeight/4;
					XEnd  =(j+1)*ScreenWidth/6;
					YEnd  =(i+1)*ScreenHeight/4;
					drawLine(XStart,YStart,XEnd,YEnd);
			}
			if (Grid[i][j].WestWall==1){
					XStart= j   *ScreenWidth/6;
					YStart=(i)*ScreenHeight/4;
					XEnd  =(j)*ScreenWidth/6;
					YEnd  =(i+1)*ScreenHeight/4;
					drawLine(XStart,YStart,XEnd,YEnd);
			}
			if(Grid[i][j].SouthWall==1){
				XStart= j   *ScreenWidth/6;
				YStart=(i)*ScreenHeight/4;
				XEnd  =(j+1)*ScreenWidth/6;
				YEnd  =(i)*ScreenHeight/4;
				drawLine(XStart,YStart,XEnd,YEnd);
			}
		}
	}
}

//=====================================================================
void DrawBot(){
	int RobotXpixelPos=0;
	int RobotYpixelPos=0;

	if(CurrentPosCol==0){
			RobotXpixelPos=ScreenWidth/12;
	}
	else{
		RobotXpixelPos=(2*CurrentPosCol+1)*ScreenWidth/12;
	}

	if(CurrentPosRow==0){
			RobotYpixelPos=ScreenHeight/8;
	}
	else{
		RobotYpixelPos=(2*CurrentPosRow+1)*ScreenHeight/8;
	}

	switch(RobotDirection){
			case 0: displayStringAt(RobotXpixelPos,RobotYpixelPos,"^");	break; // Facing North
			case 1: displayStringAt(RobotXpixelPos,RobotYpixelPos,">"); break; // Facing East
			case 2: displayStringAt(RobotXpixelPos,RobotYpixelPos,"V"); break; // Facing South
			case 3: displayStringAt(RobotXpixelPos,RobotYpixelPos,"<"); break; // Facing West
			default: break;
	}
}
//=====================================================================
void toStart() {
	TargetPosCol = 0;
	TargetPosRow = 0;
	// Use grouping to find the shortest path
	int grouped = 1;

	// Put into a tmp array
	int tmp[100];
	for (int i = 0; i < 100; i++) {
		tmp[i] = path[i];
	}

	// Continue so long as a grouped was found on the previous iteration, if no grouping then this is the shortest path
	while (grouped) {
		grouped = 0;
		int reducedCount = 0;
		for (int i = 0; i < moves -1; i++) {
			// if opposite remove from pathset
			if (i == -1) {
				continue;
			}

			if (abs(path[i] - path[i+1]) == 2) {
				path[i] = -1;
				path[i+1] = -1;
				i++;
				grouped = 1;
			}
			else {
				// Add to the tmp array
				tmp[reducedCount] = path[i];
				reducedCount += 1;
			}
		}

		if (path[moves-1] != -1) {
			tmp[reducedCount] = path[moves-1];
			reducedCount += 1;
		}

		// Copy temp back into the main arr
		for (int i = 0; i < reducedCount; i++) {
			path[i] = tmp[i];
		}
		moves = reducedCount;
	}

	// Reverse the directions
	for (int i = 0; i < moves; i++) {
		if (path[i] != -1) {
			path[i] = (path[i] + 2) % 4;
		}
	}

	// Follow reversed path
	for (int i = moves - 1; i >= 0; i--) {
		if (path[i] > -1) {
			orient(path[i]);
			fwd();
		}
	}
	return;
}

void orient(int target) {
	if ((RobotDirection + 1) % 4 == target) {
		// turn right
		turnRight();
		RobotDirection = target;

	}
	else if ((RobotDirection + 2) % 4 == target) {
		// turn 180 degrees
		turn180();
		RobotDirection = target;
	}
	else if ((RobotDirection + 3) % 4 == target) {
		// turn left
		turnLeft();
		RobotDirection = target;
	}
}

void fwd() {
	moveRobot(tileDegrees, tileDegrees, speed);
	previousTile[0] = CurrentPosRow;
	previousTile[1] = CurrentPosCol;

	// should be in the next tile
	switch (RobotDirection)
	{
		case 0:
			CurrentPosRow+=1;
			break;
		case 1:
			CurrentPosCol+=1;
			break;
		case 2:
			CurrentPosRow-=1;
			break;
		case 3:
			CurrentPosCol-=1;
			break;
		default:
			break;
	}
	Grid[CurrentPosRow][CurrentPosCol].Visited=1;
	path[moves] = RobotDirection;
	moves+=1;
	return;
}

int Solver(){
	/*
	Uses right hand rule algorithm
	*/
	int wallCount = 1;
	while (CurrentPosRow != TargetPosRow
		|| CurrentPosCol != TargetPosCol) {

        int count = 0;

		// Check and update wall status; if within bounds there's a wall
		while (getUSDistance(us_sensor) < tileSize * 0.7) {
			wallCount += 1;
            if (RobotDirection == 0) {
				if (Grid[CurrentPosRow][CurrentPosCol].NorthWall == -1) {
					Grid[CurrentPosRow][CurrentPosCol].VisitCount +=1;
				}
				Grid[CurrentPosRow][CurrentPosCol].NorthWall = 1;
			}
			else if (RobotDirection == 1) {
				if (Grid[CurrentPosRow][CurrentPosCol].EastWall == -1) {
					Grid[CurrentPosRow][CurrentPosCol].VisitCount +=1;
				}
				Grid[CurrentPosRow][CurrentPosCol].EastWall = 1;
			}
			else if (RobotDirection == 2) {
				if (Grid[CurrentPosRow][CurrentPosCol].SouthWall == -1) {
					Grid[CurrentPosRow][CurrentPosCol].VisitCount +=1;
				}
				Grid[CurrentPosRow][CurrentPosCol].SouthWall = 1;
			}
			else if (RobotDirection == 3) {
				if (Grid[CurrentPosRow][CurrentPosCol].WestWall == -1) {
					Grid[CurrentPosRow][CurrentPosCol].VisitCount +=1;
				}
				Grid[CurrentPosRow][CurrentPosCol].WestWall = 1;
			}
			/* Push up to the wall to flatten the angle?*/
			if ((wallCount % 2)) {
				while(!getTouchValue(touchA) || !getTouchValue(touchB)) {
					if (!getTouchValue(touchA)) {
						setMotorSpeed(left_motor, speed);
					}
					else {
						setMotorSpeed(left_motor, 0);
					}
					if (!getTouchValue(touchB)) {
						setMotorSpeed(right_motor, speed);
					}
					else {
						setMotorSpeed(right_motor, 0);
					}
				}
				setMotorSpeed(left_motor, 0);
				setMotorSpeed(right_motor, 0);
				waitUntilMotorStop(left_motor);
				waitUntilMotorStop(right_motor);
			}
			// back up to distance
			while (getUSDistance(us_sensor) < wallDistance * 0.96) {
                resetMotorEncoder(left_motor);
                resetMotorEncoder(right_motor);
				setMotorSpeed(left_motor, -speed);
				setMotorSpeed(right_motor,-speed);
            }
			setMotorSpeed(left_motor, 0);
			setMotorSpeed(right_motor, 0);
			waitUntilMotorStop(left_motor);
			waitUntilMotorStop(right_motor);

			count = 0;
			if (Grid[CurrentPosRow][CurrentPosCol].NorthWall == 1) {
				count += 1;
			}
			if (Grid[CurrentPosRow][CurrentPosCol].EastWall == 1) {
				count += 1;
			}
			if (Grid[CurrentPosRow][CurrentPosCol].SouthWall == 1) {
				count += 1;
			}
			if (Grid[CurrentPosRow][CurrentPosCol].WestWall == 1) {
				count += 1;
			}
			if (count == 3) {
				playTone(100, 100);
				if (Grid[CurrentPosRow][CurrentPosCol].NorthWall == 0) {
					if (RobotDirection == 1) {
						turnLeft();
					}
					else if (RobotDirection == 2) {
						turn180();
					}
					else if (RobotDirection == 3) {
						turnRight();
					}
				}
				else if (Grid[CurrentPosRow][CurrentPosCol].EastWall == 0) {
					if (RobotDirection == 2) {
						turnLeft();
					}
					else if (RobotDirection == 3) {
						turn180();
					}
					else if (RobotDirection == 0) {
						turnRight();
					}
				}
				else if (Grid[CurrentPosRow][CurrentPosCol].SouthWall == 0) {
					if (RobotDirection == 3) {
						turnLeft();
					}
					else if (RobotDirection == 0) {
						turn180();
					}
					else if (RobotDirection == 1) {
						turnRight();
					}
				}
				else if (Grid[CurrentPosRow][CurrentPosCol].WestWall == 0) {
					if (RobotDirection == 0) {
						turnLeft();
					}
					else if (RobotDirection == 1) {
						turn180();
					}
					else if (RobotDirection == 2) {
						turnRight();
					}
				}
			}
			else if(Grid[CurrentPosRow][CurrentPosCol].VisitCount == 4 && count < 3 && nextRightPrevious()) {
				turn180();
			}
			else {
				turnRight();
			}
		}

        int nextCellRow = CurrentPosRow;
        int nextCellCol = CurrentPosCol;
		switch(RobotDirection) {
			// North
        	case 0:
				nextCellRow += 1;
				break;
			case 1:
                nextCellCol += 1;
				break;
			case 2:
                nextCellRow -= 1;
				break;
			case 3:
                nextCellCol -= 1;
				break;
			default:
				break;
		}
		if (Grid[nextCellRow][nextCellCol].Visited && Grid[CurrentPosRow][CurrentPosCol].VisitCount < 4) {
			turnRight();
			continue;
		}

        fwd();
        displayCenteredBigTextLine(5, "[%d, %d]", CurrentPosRow, CurrentPosCol);

	}


	// Found the objective
	playTone(300, 200);
	wait1Msec(2000);
	toStart();
	return 1;
}

//=====================================================================
void DisplayStartandEnd(){
	int XpixelPos=0;
	int YpixelPos=0;

	if(StartPosCol==0){
			XpixelPos=ScreenWidth/12;
	}
	else{
		XpixelPos=(2*StartPosCol+1)*ScreenWidth/12;
	}

	if(StartPosRow==0){
			YpixelPos=ScreenHeight/8;
	}
	else{
		YpixelPos=(2*StartPosRow+1)*ScreenHeight/8;
	}
	displayStringAt(XpixelPos,YpixelPos,"S");

	if(TargetPosCol==0){
			XpixelPos=ScreenWidth/12;
	}
	else{
		XpixelPos=(2*TargetPosCol+1)*ScreenWidth/12;
	}

	if(TargetPosRow==0){
			YpixelPos=ScreenHeight/8;
	}
	else{
		YpixelPos=(2*TargetPosRow+1)*ScreenHeight/8;
	}
	displayStringAt(XpixelPos,YpixelPos,"E");
}
